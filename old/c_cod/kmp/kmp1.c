#include<stdio.h>
#include<string.h>
#include<malloc.h>


void nextstr(char *s,int *a,int l){
    int k=-1,j=0;  //k保存前后缀字符相等个数    j保存字符串遍历到哪了
    a[0]=-1;  //-1符合前后缀判断语义又设计的极其巧妙   规定字符串第一个字母的前后缀最大长度为-1,因为第一个字母前面没有字母，没的比较
    a[1]=0;    //第二个字符前缀与后缀都是第一个字符，不算做长度，或者意为后缀为空，  注意，第n个保存的是前面字符第1到第n-1字符最大前后缀长度，不包括第n个
    while(j<l){
        if(k==-1 || s[k]==s[j] ){  //判断相等就两个步进都加，k=-1时则代表前面已经判断过不相等       
            k++;
            j++;
            a[j]=k;   //根据定义，如果找到前后缀长度了，就把长度保存在后一个位置。
        }else{
            k=a[k];
            //全算法最秀语句。
            //这个语句有两个作用
            //一。为k重新赋值为-1向下一次循环传递信息,代表判断字符不等，k与j都要向后移动。  这也是前面吧a[0]设置为-1这个特殊值的意义所在
            //二，假如已经在后面字符串中找到前缀字符一些片段，这时候在再向后匹配，是不是就等于跟自己匹配开始的时候，而这个匹配开始做过了呀
            //结果就在a数组前面。所以这一步目的就是把做过的结果，再复制一边，有几个相等，复制几个。这个天秀。直到k从新回溯到-1,那么新的跟自己前面不一样的匹配又开始了。
        }
    }
    // printf("\n");
    // for(int ii=0;ii<l;ii++){
    //      printf("%d",a[ii]);
    // }
}
//kmp算法主要思想在我看来就一个，处理特殊字符串，就是自己长得跟自己很像的字符串，匹配的时候需要准确步进，例如象abc这种完全”独特“的字符串，ab匹配c不匹配时，直接就步进三个了，无需a在跟b
//比较。直接拿a比较c后一个字符。解决麻烦开头相似，后面有不相似的问题。
int kmp(char *s,char *ss){
    int k=-1,j=-1,ll=strlen(ss),l=strlen(s);
    int a[l];
    nextstr(s,a,l);
    while(k<l && j<ll){
        if(k==-1 || s[k]==ss[j]){            //成功匹配唯一条件，完成这个循环，让k等于匹配字符串长度。
            j++;k++;                        //其他其他情况，则根据匹配字符自己与自己的相似度进行快速准确步进，
        }else{
            k=a[k];                       //万一出现一个字符匹配不相同时，查询自身匹配的表，看看是否与要步进到与自身相似的部位。如果完全不同k=0，直接跳过匹配过的字符
        }                                //从主字符串j处，与匹配字符开头匹配。
    }
    if(k==l){
            printf("位置在%d",j-l+1);   //成功条件就是k把匹配字符取完了，并且都在主串找到了。
            return j-l+1;
        }else{
            printf("找不到");
            return -1;
        }
}

int main(){
    return 1;
}